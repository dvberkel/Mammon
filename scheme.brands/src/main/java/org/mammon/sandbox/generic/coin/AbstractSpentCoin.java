package org.mammon.sandbox.generic.coin;

import java.lang.reflect.Array;

import org.mammon.AssetType;
import org.mammon.math.FiniteField;
import org.mammon.math.Group;
import org.mammon.sandbox.generic.accountholder.AbstractAccountHolderPrivate;
import org.mammon.sandbox.generic.shop.AbstractShop;
import org.mammon.scheme.brands.BrandsSchemeSetup;
import org.mammon.scheme.brands.PaymentHashFunction;
import org.mammon.scheme.brands.SignatureHashFunction;
import org.mammon.scheme.brands.bank.Bank;
import org.mammon.scheme.brands.coin.CoinSignature;
import org.mammon.scheme.brands.coin.SpentCoin;
import org.mammon.scheme.brands.coin.UnspentCoin;
import org.mammon.scheme.brands.shop.Shop;
import org.mammon.util.HashCodeUtil;

public class AbstractSpentCoin<G extends Group<G>, F extends FiniteField<F>, I, T, H extends SignatureHashFunction<G, F>, H0 extends PaymentHashFunction<G, F, I, T>>
		implements SpentCoin<G, F, I, T, H, H0> {

	private final BrandsSchemeSetup<G, F, I, T, H, H0> setup;

	private final Bank<G, F, I, T, H, H0> bank;

	private final Shop<G, F, I, T, H, H0> bearer;

	private final T time;

	private final Group.Element<G> blindedIdentity;

	private final Group.Element<G> commitment;

	private final CoinSignature<G, F> coinSignature;

	private final FiniteField.Element<F>[] spendingCommitments;

	private final AssetType assetType;

	private final Number faceValue;

	@SuppressWarnings("unchecked")
	public AbstractSpentCoin(UnspentCoin<G, F, I, T, H, H0> basedOnCoin, Bank<G, F, I, T, H, H0> bank,
			AbstractShop<G, F, I, T, H, H0> bearer, T time) {
		setup = basedOnCoin.getSetup();
		this.bank = bank;
		this.bearer = bearer;
		this.time = time;

		blindedIdentity = basedOnCoin.getBlindedIdentity();
		commitment = basedOnCoin.getCommitment();
		coinSignature = basedOnCoin.getCoinSignature();
		assetType = basedOnCoin.getAssetType();
		faceValue = basedOnCoin.getFaceValue();

		// Generated by shop
		FiniteField.Element<F> d = setup.getPaymentHash().hash(blindedIdentity, commitment, bearer.getIdentity(), time);

		// Generated by account holder
		spendingCommitments = (FiniteField.Element<F>[]) Array.newInstance(FiniteField.Element.class, 2);
		spendingCommitments[0] = d.multiply(
				((AbstractAccountHolderPrivate<G, F, I, T, H, H0>) basedOnCoin.getBearer()).getPrivateKey()).multiply(
				basedOnCoin.getBlindingFactor()).add(basedOnCoin.getPayerWitness()[0]);
		spendingCommitments[1] = d.multiply(basedOnCoin.getBlindingFactor()).add(basedOnCoin.getPayerWitness()[1]);

		// Tested by shop
		Group.Element<G> left = setup.getGenerators()[1].exponentiate(spendingCommitments[0]).multiply(
				setup.getGenerators()[2].exponentiate(spendingCommitments[1]));
		Group.Element<G> right = blindedIdentity.exponentiate(d).multiply(commitment);
		System.out.println(left.equals(right));
	}

	@Override
	public Shop<G, F, I, T, H, H0> getBearer() {
		return bearer;
	}

	@Override
	public FiniteField.Element<F>[] getSpendingCommitments() {
		return spendingCommitments;
	}

	@Override
	public T getTime() {
		return time;
	}

	@Override
	public Group.Element<G> getBlindedIdentity() {
		return blindedIdentity;
	}

	@Override
	public CoinSignature<G, F> getCoinSignature() {
		return coinSignature;
	}

	@Override
	public Group.Element<G> getCommitment() {
		return commitment;
	}

	@Override
	public Bank<G, F, I, T, H, H0> getIssuer() {
		return bank;
	}

	@Override
	public BrandsSchemeSetup<G, F, I, T, H, H0> getSetup() {
		return setup;
	}

	@Override
	public AssetType getAssetType() {
		return assetType;
	}

	@Override
	public Number getFaceValue() {
		return faceValue;
	}

	@Override
	public boolean isSellable() {
		return false;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == null || !(obj instanceof AbstractSpentCoin<?, ?, ?, ?, ?, ?>)) {
			return false;
		}
		AbstractSpentCoin<?, ?, ?, ?, ?, ?> other = (AbstractSpentCoin<?, ?, ?, ?, ?, ?>) obj;
		return setup.equals(other.setup) && bank.equals(other.bank) && bearer.equals(other.bearer)
				&& blindedIdentity.equals(other.blindedIdentity) && commitment.equals(other.commitment)
				&& coinSignature.equals(other.coinSignature);
	}

	@Override
	public int hashCode() {
		int hashCode = HashCodeUtil.SEED;
		hashCode = HashCodeUtil.hash(hashCode, setup);
		hashCode = HashCodeUtil.hash(hashCode, bank);
		hashCode = HashCodeUtil.hash(hashCode, bearer);
		hashCode = HashCodeUtil.hash(hashCode, blindedIdentity);
		hashCode = HashCodeUtil.hash(hashCode, commitment);
		hashCode = HashCodeUtil.hash(hashCode, coinSignature);
		return hashCode;
	}

}

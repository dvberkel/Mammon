package org.mammon.brands.example;

import java.lang.reflect.Array;
import java.util.Arrays;

import org.mammon.AssetType;
import org.mammon.brands.AccountHolder;
import org.mammon.brands.Bank;
import org.mammon.brands.BrandsSchemeSetup;
import org.mammon.brands.Group;
import org.mammon.brands.PaymentHashFunction;
import org.mammon.brands.SignatureHashFunction;
import org.mammon.brands.UnspentCoin;
import org.mammon.brands.Group.Element;
import org.mammon.brands.example.ExampleGroup.ExampleElement;

public class ExampleUnspentCoin<G extends Group<G>, S, T, H extends SignatureHashFunction<G>, H0 extends PaymentHashFunction<G, S, T>>
		implements UnspentCoin<G, S, T, H, H0> {

	private final BrandsSchemeSetup<G, S, T, H, H0> setup;

	private final ExampleAccountHolder<G, S, T, H, H0> bearer;

	private final ExampleBank<G, S, T, H, H0> bank;

	private final Element<G> blindingFactor;

	private final Element<G>[] payerWitness;

	private final Element<G> blindedIdentity;

	private final Element<G> commitment;

	private final Element<G>[] coinSignature;

	@SuppressWarnings("unchecked")
	public ExampleUnspentCoin(BrandsSchemeSetup<G, S, T, H, H0> setup, ExampleAccountHolder<G, S, T, H, H0> bearer,
			ExampleBank<G, S, T, H, H0> bank) {
		this.setup = setup;
		this.bearer = bearer;
		this.bank = bank;

		// Generated by bank
		Element<G> w = setup.getGroup().getRandomElement(null); // secret in
		// bank
		Element<G> a = setup.getGenerators()[0].exponentiate(w); // sent to
		// account
		// holder
		Element<G> b = bearer.getPublicKey().multiply(setup.getGenerators()[2]).exponentiate(w); // sent
		// to
		// account
		// holder

		// Generated by account holder
		blindingFactor = setup.getGroup().getRandomElement(null);
		payerWitness = (Element<G>[]) Array.newInstance(Element.class, 2);
		payerWitness[0] = setup.getGroup().getRandomElement(null); // x_1
		payerWitness[1] = setup.getGroup().getRandomElement(null); // x_2
		Element<G> u = setup.getGroup().getRandomElement(null);
		Element<G> v = setup.getGroup().getRandomElement(null);

		blindedIdentity = bearer.getPublicKey().multiply(setup.getGenerators()[2]).exponentiate(blindingFactor); // A
		Element<G> z_ = bearer.getBlindedIdentity().exponentiate(blindingFactor);
		commitment = setup.getGenerators()[1].exponentiate(payerWitness[0]).multiply(
				setup.getGenerators()[2].exponentiate(payerWitness[1])); // B

		Element<G> a_ = a.exponentiate(u).multiply(setup.getGenerators()[0].exponentiate(v));
		Element<G> b_ = b.exponentiate(blindingFactor.multiply(u)).multiply(blindedIdentity.exponentiate(v));

		Element<G> c_ = setup.getSignatureHash().hash(blindedIdentity, commitment, z_, a_, b_);
		Element<G> c = c_.multiply(u.getInverse());

		// Generated by bank
		Element<G> r = c.multiply(bank.getPrivateKey()).add(w);

		// Tested by account holder
		ExampleElement left = (ExampleElement) setup.getGenerators()[0].exponentiate(r);
		ExampleElement right = (ExampleElement) bank.getPublicKey().exponentiate(c).multiply(a);
		System.out.println(left.simplify() + " <= from: " + left);
		System.out.println(right.simplify() + " <= from: " + right);
		System.out.println(left.simplify().equals(right.simplify()));

		// Tested by account holder
		left = (ExampleElement) bearer.getPublicKey().multiply(setup.getGenerators()[2]).exponentiate(r);
		right = (ExampleElement) bearer.getBlindedIdentity().exponentiate(c).multiply(b);
		System.out.println(left.simplify() + " <= from: " + left);
		System.out.println(right.simplify() + " <= from: " + right);
		System.out.println(left.simplify().equals(right.simplify()));

		// Generated by account holder
		Element<G> r_ = r.multiply(u).add(v);
		coinSignature = (Element<G>[]) Array.newInstance(Element.class, 4);
		coinSignature[0] = z_;
		coinSignature[1] = a_;
		coinSignature[2] = b_;
		coinSignature[3] = r_;
	}

	@Override
	public AccountHolder<G, S, T, H, H0> getBearer() {
		return bearer;
	}

	@Override
	public Element<G> getBlindingFactor() {
		return blindingFactor;
	}

	@Override
	public Element<G>[] getPayerWitness() {
		return payerWitness.clone();
	}

	@Override
	public Element<G> getBlindedIdentity() {
		return blindedIdentity;
	}

	@Override
	public Element<G>[] getCoinSignature() {
		return coinSignature;
	}

	@Override
	public Element<G> getCommitment() {
		return commitment;
	}

	@Override
	public Bank<G, S, T, H, H0> getIssuer() {
		return bank;
	}

	@Override
	public BrandsSchemeSetup<G, S, T, H, H0> getSetup() {
		return setup;
	}

	@Override
	public AssetType getAssetType() {
		return new AssetType() {

			@Override
			public String getCallSign() {
				return "EUR";
			}
		};
	}

	@Override
	public Number getFaceValue() {
		return Integer.valueOf(1);
	}

	@Override
	public boolean isSellable() {
		return true;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == null || !(obj instanceof ExampleUnspentCoin<?, ?, ?, ?, ?>)) {
			return false;
		}
		ExampleUnspentCoin<?, ?, ?, ?, ?> other = (ExampleUnspentCoin<?, ?, ?, ?, ?>) obj;
		return setup.equals(other.setup) && bank.equals(other.bank) && bearer.equals(other.bearer)
				&& blindingFactor.equals(other.blindingFactor) && Arrays.deepEquals(payerWitness, other.payerWitness);
	}

	@Override
	public int hashCode() {
		int hashCode = HashCodeUtil.SEED;
		hashCode = HashCodeUtil.hash(hashCode, setup);
		hashCode = HashCodeUtil.hash(hashCode, bank);
		hashCode = HashCodeUtil.hash(hashCode, bearer);
		hashCode = HashCodeUtil.hash(hashCode, blindingFactor);
		hashCode = HashCodeUtil.hash(hashCode, payerWitness);
		return hashCode;
	}

	@Override
	public String toString() {
		return "I, " + bank + ", owe the bearer of this IOU, " + bearer + ", the repayment of "
				+ getAssetType().getCallSign() + " " + getFaceValue() + " [BF=" + blindingFactor + ", PW=("
				+ getPayerWitness()[0] + "," + getPayerWitness()[1] + "), COIN=(" + getBlindedIdentity() + ","
				+ getCommitment() + ",(" + getCoinSignature()[0] + "," + getCoinSignature()[1] + ","
				+ getCoinSignature()[2] + "," + getCoinSignature()[3] + "))]";
	}

}
